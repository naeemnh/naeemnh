import React, { useEffect, useRef, useState } from 'react';
import styles from './canvas.module.css';
import { Star } from '@/types/star.class';

const CanvasAnimation = () => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [windowWidth, setWindowWidth] = useState<number>(window?.innerWidth);
  const [windowHeight, setWindowHeight] = useState<number>(window?.innerHeight);
  const isDark = typeof window !== 'undefined' && window.matchMedia('(prefers-color-scheme: dark)');
  // const [isDark, setIsDark] = useState<false | MediaQueryList>(window?.matchMedia('prefers-color-scheme: dark)'))
  const animationFrameRef = useRef<number | null>(null);

  useEffect(() => {
    // if (typeof window != 'undefined') {
    //   setIsDark(window.matchMedia('prefers-color-scheme: dark)'))
    // }
    const handleWindowResize = (): void => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
      setWindowHeight(window.innerHeight);
      setWindowWidth(window.innerWidth);
    };

    const animateCanvas = (w: number, h: number) => {
      const canvas = canvasRef.current;
      if (!canvas) return
      canvas.width = w;
      canvas.height = h;
      const ctx = canvas!.getContext('2d');
      const background = isDark && isDark.matches ? '#000' : '#fff';
      const colorStops = isDark && isDark.matches
        ? [
          { offset: 0.025, color: '#fff' },
          { offset: 0.1, color: 'hsl(217, 61%, 33%)' },
          { offset: 0.25, color: 'hsl(217, 64%, 6%)' },
          { offset: 1, color: 'transparent' },
        ]
        : [
          { offset: 0.025, color: '#000' },
          { offset: 0.25, color: 'transparent' },
          { offset: 0.5, color: 'transparent' },
          { offset: 1, color: 'transparent' },
        ];

      const canvas2 = document.createElement('canvas');
      const ctx2 = canvas2.getContext('2d');
      if (!ctx2) return
      canvas2.width = 100;
      canvas2.height = 100;
      const half = canvas2.width / 2;
      const gradient2 = ctx2!.createRadialGradient(half, half, 0, half, half, half);
      colorStops.forEach(({ offset, color }) => {
        gradient2.addColorStop(offset, color);
      });
      ctx2.fillStyle = gradient2;
      ctx2.beginPath();
      ctx2.arc(half, half, half, 0, Math.PI * 2);
      ctx2.fill();

      const maxStars = 1000;
      const stars: Star[] = [];
      let count = 0;

      for (let i = 0; i < maxStars; i++) {
        stars.push(new Star(w, h, count, stars, maxStars));
      }

      function animation(): void {
        if (!ctx) return
        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = 0.8;
        ctx.fillStyle = background;
        ctx.fillRect(0, 0, w, h);

        ctx.globalCompositeOperation = 'darken';
        ctx.globalCompositeOperation = isDark && isDark.matches ? 'lighter' : 'darken';

        for (let i = 1, l = stars.length; i < l; i++) {
          stars[i].draw(ctx, canvas2);
        }

        animationFrameRef.current = requestAnimationFrame(animation);
      }

      animation();
    };

    typeof window !== 'undefined' && window.addEventListener('resize', handleWindowResize);

    animateCanvas(windowWidth, windowHeight);

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
      window.removeEventListener('resize', handleWindowResize);
    };
  }, [windowHeight, windowWidth, canvasRef, isDark]);

  return <canvas ref={canvasRef} className={styles.canvas}></canvas>;
};

export default CanvasAnimation;
